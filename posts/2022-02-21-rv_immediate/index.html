<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.97.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Quentin Ducasse" />
  <meta property="og:url" content="https://qducasse.github.io/posts/2022-02-21-rv_immediate/" />
  <link rel="canonical" href="https://qducasse.github.io/posts/2022-02-21-rv_immediate/" /><link rel="alternate" type="application/atom+xml" href="https://qducasse.github.ioindex.xml" title="Lectern">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/qducasse.github.io"
      },
      "articleSection" : "posts",
      "name" : "RISC-V load immediate pseudo-instruction",
      "headline" : "RISC-V load immediate pseudo-instruction",
      "description" : "RISC-V Load Immediate li Pseudo-Instruction The pseudo-instruction li breaks down to a complex algorithm depending on the variables. Before presenting the algorithm, some terms have to be defined.\nTerms and Concepts Numbers and Sign First, an unsigned number has its raw value in binary and cannot be negative. There is no guess on how to read the value, each bit will only represent a power of two.\n 1 0 1 1 2^3 2^2 2^1 2^0 8 \u002b 0 \u002b 2 \u002b 1 = 11 Next, a signed integer will have its most significant bit set to a sign bit.",
      "inLanguage" : "en-US",
      "author" : "Quentin Ducasse",
      "creator" : "Quentin Ducasse",
      "publisher": "Quentin Ducasse",
      "accountablePerson" : "Quentin Ducasse",
      "copyrightHolder" : "Quentin Ducasse",
      "copyrightYear" : "2022",
      "datePublished": "2022-02-21 00:00:00 \u002b0000 UTC",
      "dateModified" : "2022-02-21 00:00:00 \u002b0000 UTC",
      "url" : "https:\/\/qducasse.github.io\/posts\/2022-02-21-rv_immediate\/",
      "keywords" : [ "riscv", ]
  }
</script>
<title>RISC-V load immediate pseudo-instruction</title>
  <meta property="og:title" content="RISC-V load immediate pseudo-instruction" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="RISC-V Load Immediate li Pseudo-Instruction The pseudo-instruction li breaks down to a complex algorithm depending on the variables. Before presenting the algorithm, some terms have to be defined.
Terms and Concepts Numbers and Sign First, an unsigned number has its raw value in binary and cannot be negative. There is no guess on how to read the value, each bit will only represent a power of two.
 1 0 1 1 2^3 2^2 2^1 2^0 8 &#43; 0 &#43; 2 &#43; 1 = 11 Next, a signed integer will have its most significant bit set to a sign bit." />
  <meta name="description" content="RISC-V Load Immediate li Pseudo-Instruction The pseudo-instruction li breaks down to a complex algorithm depending on the variables. Before presenting the algorithm, some terms have to be defined.
Terms and Concepts Numbers and Sign First, an unsigned number has its raw value in binary and cannot be negative. There is no guess on how to read the value, each bit will only represent a power of two.
 1 0 1 1 2^3 2^2 2^1 2^0 8 &#43; 0 &#43; 2 &#43; 1 = 11 Next, a signed integer will have its most significant bit set to a sign bit." />
  <meta property="og:locale" content="en" /><meta property="og:image" content="" />
  

  
    <style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:1000px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{margin:0;padding:0 1em;color:#57606a;border-left:.25em solid #d0d7de}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1.2rem;margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{text-align:center}.posts-line{font-size:16px}.markdown-body{font-size:16px}.post-title{font-size:2rem}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}</style>
  
  
    <style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style>
  

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Lectern">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet">
  
  

  
  
</head>


<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="header-title">
    <a href="/"
      >Lectern</a
    >
  </div>
  <div class="header-subtitle">Notes and Memos, Quentin DUCASSE</div>
</header>
<div class="row end-md center-xs header-items">
  
  <div class="header-item">
    <a href="https://github.com/QDucasse" target="_blank">Github</a>
  </div>
  
  <div class="header-item">
    <a href="https://twitter.com/quentin_ducasse" target="_blank">Twitter</a>
  </div>
  
</div>
<div class="row end-xs">
   
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">RISC-V load immediate pseudo-instruction</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2022-02-21 00:00:00 UTC">
                21 Feb 2022
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="">@Quentin Ducasse</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <h1 id="risc-v-load-immediate-li-pseudo-instruction">RISC-V Load Immediate <code>li</code> Pseudo-Instruction</h1>
<p>The pseudo-instruction <code>li</code> breaks down to a complex algorithm depending on the variables. Before presenting the algorithm, some terms have to be defined.</p>
<h2 id="terms-and-concepts">Terms and Concepts</h2>
<h3 id="numbers-and-sign">Numbers and Sign</h3>
<p>First, an <strong>unsigned number</strong> has its raw value in binary and cannot be negative. There is no guess on how to read the value, each bit will only represent a power of two.</p>
<pre tabindex="0"><code> 1   0   1   1
2^3 2^2 2^1 2^0
 8 + 0 + 2 + 1  = 11
</code></pre><p>Next, a <strong>signed integer</strong> will have its most significant bit set to a sign bit. A naive representation would be to note if the sign bit is one, in which case the number is negative, then interpret the rest of the number. However, this makes the value 0 and -0 have a different representation.</p>
<pre tabindex="0"><code> 1   0   1   1
 -  2^2 2^1 2^0
 - ( 0 + 2 + 1 ) = -3
</code></pre><p>Another issue with this representation is the fact that you have to take extra care of operations. For example:</p>
<pre tabindex="0"><code>   1011 (-3)
 + 1010 (-2)
 ______
   0101 (+5)  X incorrect
</code></pre><p>The real answer is <code>10101</code> but if we are limited to 4 bits, the extra digit is simply lost&hellip;</p>
<p>The solution to this representation is <strong>two&rsquo;s complement</strong>, inverting all bits of the positive integer and add 1 to get its negative representation.</p>
<pre tabindex="0"><code>7 --&gt; 0111 --&gt; 1000 --&gt; 1001 --&gt; -7
       (7)   (2s ct)    (+1)     
</code></pre><p>If we now try another operation:</p>
<pre tabindex="0"><code>	1001 (-7)
  + 0100 (+4)
  ______
    1101  sign bit up so the value is negative!
   	      remove bit sign and subtract 1 -&gt; 100 = 4
      =&gt; -4  CORRECT!
</code></pre><h3 id="in-pharo">In Pharo</h3>
<p>While these are basic number representation concepts, in Pharo, writing <code>-16rF22</code> is possible and the inspector will tell you it is equal to -3874. However, if what you mean is <em>perform the two&rsquo;s complement of that number</em>, you can use a function such as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-smalltalk" data-lang="smalltalk"><span style="display:flex;"><span><span style="color:#a6e22e">computeSignedValueOf:</span> aValue <span style="color:#a6e22e">ofSize:</span> aSize
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">&#34;If the number is negative, returns two&#39;s complement, otherwise return the value&#34;</span>
</span></span><span style="display:flex;"><span>	aValue <span style="color:#a6e22e">&lt;</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		ifTrue: [ <span style="color:#f92672">^</span> aValue <span style="color:#a6e22e">twoComplementOfBitSize:</span> aSize ]  <span style="color:#75715e">&#34;Compute two&#39;s complement&#34;</span>
</span></span><span style="display:flex;"><span>		ifFalse: [ <span style="color:#f92672">^</span> aValue ]
</span></span></code></pre></div><h3 id="sign-extension">Sign Extension</h3>
<p>Another concept that is important regarding signed and unsigned numbers is the concept of <strong>sign extension</strong> and <strong>zero extension</strong>. When moving a number around or extracting a number from a bit array, it is important to <strong>extend</strong> it to the destination size. How should you extend it then? Add 0s as the higher bits?</p>
<p>Two methods coexist: the first one is called <strong>sign-extension</strong> and will write the sign bit of the number as all the higher bits while <strong>zero-extension</strong> will write 0s. The first one has to be used when dealing with <strong>signed numbers</strong> while the latter is preferred for <strong>unsigned numbers</strong>.</p>
<p>For example, moving the signed value -222 (<code>16r22</code> with the smallest size of 8 bits) should be <strong>sign-extended</strong> to <code>16rFFFFFF22</code> when moved in a 32-bits register. This will not change the value due to how two&rsquo;s complement work! On the other hand, when moving an unsigned number it is important to keep the bits raw as they directly represent the number.</p>
<p>In C or C++, sign-extension is usually performed as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">uint64_t</span> x;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Extract the lower n bits of x and sign-extend them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int64_t</span> low12 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int64_t</span>)((x <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span> n)) <span style="color:#f92672">&gt;&gt;</span> (<span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span>n))
</span></span></code></pre></div><p>Using the fact that causing an overflow in a left shift will truncate the number, shifting left then shifting right the same amount will truncate the value at the given shift amount. The cast to <code>int64_t</code> from <code>uint64_t</code> will perform the sign extension!</p>
<h2 id="load-immediate-li-pseudo-instruction">Load Immediate <code>li</code> pseudo-instruction</h2>
<p>Loading an immediate in RISC-V means loading a raw value in a register. While this can be done with a single load operation on architectures such as x86, the path is more convoluted for RISC-V.</p>
<h3 id="instructions-available">Instructions Available</h3>
<p>We have four different instructions that we can combine to load a particular immediate. Those are:</p>
<ul>
<li>
<p><strong>Load Upper Immediate <code>lui</code>:</strong> Writes the <strong>sign-extended</strong> 20-bit immediate, left-shifted by 12 bits to x[<em>rd</em>], zeroing the lower 12 bits. This translates to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>x<span style="color:#f92672">[</span>rd<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sext(immediate<span style="color:#f92672">[</span><span style="color:#ae81ff">31</span>:<span style="color:#ae81ff">12</span><span style="color:#f92672">]</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>)
</span></span></code></pre></div></li>
<li>
<p><strong>Add Immediate <code>addi</code>:</strong> Adds the <strong>sign-extended</strong> 12-bits immediate to register x[<em>rs1</em>] and writes the result to x[<em>rd</em>]. This translates to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>x<span style="color:#f92672">[</span>rd<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">[</span>rs1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> sext(immediate)
</span></span></code></pre></div></li>
<li>
<p><strong>Add Word Immediate <code>addiw</code>:</strong> Adds the <strong>sign-extended</strong> 12-bits immediate to register x[<em>rs1</em>], truncates the result to 32 bits, and writes the <strong>sign-extended</strong> result to x[<em>rd</em>]. This translates to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>x<span style="color:#f92672">[</span>rd<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sext((x<span style="color:#f92672">[</span>rs1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> sext(immediate))<span style="color:#f92672">[</span><span style="color:#ae81ff">31</span>:<span style="color:#ae81ff">0</span><span style="color:#f92672">]</span>)  
</span></span></code></pre></div></li>
<li>
<p><strong>Shift Left Logical Immediate <code>slli</code>:</strong> Shifts register x[<em>rs1</em>] left by <em>shamt</em> positions. The vacated bits are filled with zeros, and the result is written to x[<em>rd</em>]. This translates to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>x<span style="color:#f92672">[</span>rd<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">[</span>rs1<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;&lt;</span> shamt
</span></span></code></pre></div></li>
</ul>
<p>Using these four instructions, we can easily (naively) figure how we could load an immediate. Depending on the size of the immediate, we can use from 1 to 8 instructions: <code>addi</code> if it fits less than 12 bits or up to <code>lui</code>, <code>addiw</code>, <code>slli</code>, <code>addi</code>, <code>slli</code>, <code>addi</code>, <code>slli</code>, <code>addi</code>. Note that the first two instructions <code>lui</code> + <code>addiw</code> can contribute up to 32 bits while the following <code>addi</code> contribute up to 12 bits each. We first emit the 32 most significant bits with <code>lui</code>+<code>addiw</code> then work our way with shifts and adds.</p>
<p>However, this idea does not work due to the fact that EACH <code>addi</code> and <code>addiw</code> performs a <strong>sign-extension</strong>. This means that if a big constant (let&rsquo;s say <code>0x7000000000000800</code> or 8070450532247930880) has to be loaded, the final part where you perform the add will get understood as a signed integer due to the most significant bit set to 1.</p>
<h3 id="asm-exploration">ASM Exploration</h3>
<p>Using <code>clang</code> and <code>llvm-objdump</code>, let&rsquo;s look at how the compiler handles the translation!</p>
<p>Using <code>clang</code> makes it possible to generate an object file from the asm with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ clang -c -target riscv64 -march<span style="color:#f92672">=</span>rv64g -g load_immediate.s -o load_immediate.o
</span></span></code></pre></div><p><code>load_immediate.s</code> is composed of:</p>
<pre tabindex="0"><code>    .org 0x1000
 main:
    li x7, 12341234
</code></pre><p>The generated object file can be read with <code>objdump</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ llvm-objdump -S load_immediate.o
</span></span></code></pre></div><p>A simple Python script automates the process in the command line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> subprocess
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Wrong arguments! Use as python immediate.py &lt;your 64-bits immediate value&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>    sys<span style="color:#f92672">.</span>exit(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;temp.s&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> file:
</span></span><span style="display:flex;"><span>    file<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;&#34;&#34;    .org 0x1000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> main:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    li x7, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#f92672">.</span>format(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>subprocess<span style="color:#f92672">.</span>run([<span style="color:#e6db74">&#39;clang&#39;</span>, <span style="color:#e6db74">&#39;-c&#39;</span>, <span style="color:#e6db74">&#39;-target&#39;</span>, <span style="color:#e6db74">&#39;riscv64&#39;</span>, <span style="color:#e6db74">&#39;-march=rv64g&#39;</span>,
</span></span><span style="display:flex;"><span>                         <span style="color:#e6db74">&#39;-g&#39;</span>, <span style="color:#e6db74">&#39;temp.s&#39;</span>, <span style="color:#e6db74">&#39;-o&#39;</span>, <span style="color:#e6db74">&#39;temp.o&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> subprocess<span style="color:#f92672">.</span>run([<span style="color:#e6db74">&#39;llvm-objdump&#39;</span>, <span style="color:#e6db74">&#39;-S&#39;</span>, <span style="color:#e6db74">&#39;temp.o&#39;</span>], stdout<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE)
</span></span><span style="display:flex;"><span>print(result<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))
</span></span></code></pre></div><h3 id="asm-examples">ASM Examples</h3>
<p>Let&rsquo;s look at some examples of the result of <code>objdump</code>:</p>
<ul>
<li>
<p><strong>7FF:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ae81ff">0000000000001000</span> main:
</span></span><span style="display:flex;"><span>;     li x7, 0x7FF
</span></span><span style="display:flex;"><span>1000: <span style="color:#ae81ff">93</span> <span style="color:#ae81ff">03</span> f0 7f          	addi	t2, zero, <span style="color:#ae81ff">2047</span>  <span style="color:#75715e"># 0x7FF</span>
</span></span></code></pre></div></li>
<li>
<p><strong>FF0:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ae81ff">0000000000001000</span> main:
</span></span><span style="display:flex;"><span>;     li x7, 0xFF0
</span></span><span style="display:flex;"><span>1000: b7 <span style="color:#ae81ff">13</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>          	lui	t2, <span style="color:#ae81ff">1</span>           <span style="color:#75715e"># 0x1</span>
</span></span><span style="display:flex;"><span>1004: 9b <span style="color:#ae81ff">83</span> <span style="color:#ae81ff">03</span> ff          	addiw	t2, t2, -16 <span style="color:#75715e"># 0xFF0</span>
</span></span></code></pre></div></li>
</ul>
<p>The first example loads the value within 11 bits (sign bit 0) so a simple <code>addi</code> is enough. On the other hand, the second value, <code>FF0</code> will be understood as the two&rsquo;s complement of 16 and the emitted instruction will be <code>addi rd, rs, -16</code>. Leaving this instruction alone will sign-extend the value -16 to the size of the register. Instead of having only the value <code>FF0</code> in the register, we would have <code>FFFFFFF0</code> (for 32 bits).  One way to solve the problem is to add 1 through <code>lui</code> so that the sign bit will be reset:</p>
<pre tabindex="0"><code>    0000 1000
  + FFFF FFF0
  ___________
    0000 0FF0
</code></pre><blockquote>
<p><strong>A simple check on the sign bit of the 12 bits immediate should work!</strong></p>
</blockquote>
<p><em>But what happens when the value <code>lui</code> should manage gets negated too?</em></p>
<hr>
<p>Let&rsquo;s look into some more ASM examples:</p>
<ul>
<li>
<p><strong>7FF00FF0:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ae81ff">0000000000001000</span> main:
</span></span><span style="display:flex;"><span>;     li x7, 0x7FF00FF0
</span></span><span style="display:flex;"><span>1000: b7 <span style="color:#ae81ff">13</span> f0 7f          	lui	t2, <span style="color:#ae81ff">524033</span>       <span style="color:#75715e"># 0x7FF01</span>
</span></span><span style="display:flex;"><span>1004: 9b <span style="color:#ae81ff">83</span> <span style="color:#ae81ff">03</span> ff          	addiw	t2, t2, -16  <span style="color:#75715e"># 0xFF0</span>
</span></span></code></pre></div></li>
<li>
<p><strong>FFF00FF0:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ae81ff">0000000000001000</span> main:
</span></span><span style="display:flex;"><span>;     li x7, 0xFFF00FF0
</span></span><span style="display:flex;"><span>1000: b7 <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">00</span>          	lui	t2, <span style="color:#ae81ff">256</span>           <span style="color:#75715e"># 0x100</span>
</span></span><span style="display:flex;"><span>1004: 9b <span style="color:#ae81ff">83</span> <span style="color:#ae81ff">13</span> f0          	addiw	t2, t2, -255  <span style="color:#75715e"># 0xF01</span>
</span></span><span style="display:flex;"><span>1008: <span style="color:#ae81ff">93</span> <span style="color:#ae81ff">93</span> c3 <span style="color:#ae81ff">00</span>          	slli	t2, t2, <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>100c: <span style="color:#ae81ff">93</span> <span style="color:#ae81ff">83</span> <span style="color:#ae81ff">03</span> ff          	addi	t2, t2, -16   <span style="color:#75715e"># 0xFF</span>
</span></span></code></pre></div></li>
</ul>
<p>While the first example is straightforward, the second one is more convoluted, we will look into this one. To handle the sign extension <code>lui</code> performs, a new instruction is added! The first two will do an addition between <code>0x00100000</code> (<code>lui</code> loads 256 then shifts it left by 12 bits) and <code>0xFFFFFF01</code> (<code>addiw</code> uses the <em><strong>sign-extended</strong></em> value -255). The result is:</p>
<pre tabindex="0"><code>   0010 0000
 + FFFF FF01
 ___________
   000F FF01
</code></pre><p>which corresponds to our value <code>0xFFF00</code> with the added 1 since the next value has the sign bit set and has to be corrected as presented in the examples earlier.</p>
<blockquote>
<p><strong>An additional instruction can handle the shift the issue and handle the problem of sign-extension for <code>lui</code>!</strong></p>
</blockquote>
<h2 id="llvm-solution">LLVM Solution</h2>
<p><em>How does LLVM handles this rather complicated algorithm (and even better than that, it can also adapt the shifts in case of scarce values)?</em></p>
<p>(<a href="https://github.com/llvm/llvm-project/blob/4c3d916c4bd2a392101c74dd270bd1e6a4fec15b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp">https://github.com/llvm/llvm-project/blob/4c3d916c4bd2a392101c74dd270bd1e6a4fec15b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp</a>)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">generateInstSeqImpl</span>(<span style="color:#66d9ef">int64_t</span> Val,
</span></span><span style="display:flex;"><span>                                 <span style="color:#66d9ef">const</span> FeatureBitset <span style="color:#f92672">&amp;</span>ActiveFeatures,
</span></span><span style="display:flex;"><span>                                 RISCVMatInt<span style="color:#f92672">::</span>InstSeq <span style="color:#f92672">&amp;</span>Res) {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Check for 64 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">bool</span> IsRV64 <span style="color:#f92672">=</span> ActiveFeatures[RISCV<span style="color:#f92672">::</span>Feature64Bit];  
</span></span><span style="display:flex;"><span>   assert(IsRV64 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;Can&#39;t emit &gt;32-bit imm for non-RV64 target&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Check if the value fits in 32-bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (isInt<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">32</span><span style="color:#f92672">&gt;</span>(Val)) {
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// Depending on the active bits in the immediate Value v, the following
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#75715e">// instruction sequences are emitted:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#75715e">// v == 0                        : ADDI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#75715e">// v[0,12) != 0 &amp;&amp; v[12,32) == 0 : ADDI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#75715e">// v[0,12) == 0 &amp;&amp; v[12,32) != 0 : LUI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#75715e">// v[0,32) != 0                  : LUI+ADDI(W)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">int64_t</span> Hi20 <span style="color:#f92672">=</span> ((Val <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x800</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFF</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int64_t</span> Lo12 <span style="color:#f92672">=</span> SignExtend64<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">12</span><span style="color:#f92672">&gt;</span>(Val);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (Hi20)
</span></span><span style="display:flex;"><span>       Res.push_back(RISCVMatInt<span style="color:#f92672">::</span>Inst(RISCV<span style="color:#f92672">::</span>LUI, Hi20));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (Lo12 <span style="color:#f92672">||</span> Hi20 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">unsigned</span> AddiOpc <span style="color:#f92672">=</span> (IsRV64 <span style="color:#f92672">&amp;&amp;</span> Hi20) <span style="color:#f92672">?</span> RISCV<span style="color:#f92672">::</span>ADDIW : RISCV<span style="color:#f92672">::</span>ADDI;
</span></span><span style="display:flex;"><span>       Res.push_back(RISCVMatInt<span style="color:#f92672">::</span>Inst(AddiOpc, Lo12));
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// In the following, constants are processed from LSB to MSB but instruction
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// emission is performed from MSB to LSB by recursively calling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// generateInstSeq. In each recursion, first the lowest 12 bits are removed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// from the constant and the optimal shift amount, which can be greater than
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// 12 bits if the constant is sparse, is determined. Then, the shifted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// remaining constant is processed recursively and gets emitted as soon as it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// fits into 32 bits. The emission of the shifts and additions is subsequently
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// performed when the recursion returns.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">int64_t</span> Lo12 <span style="color:#f92672">=</span> SignExtend64<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">12</span><span style="color:#f92672">&gt;</span>(Val); <span style="color:#75715e">// (int64_t)((Val &lt;&lt; (64 -12)) &gt;&gt; (64 -12))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">int64_t</span> Hi52 <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uint64_t</span>)Val <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x800ull</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">int</span> ShiftAmount <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span> <span style="color:#f92672">+</span> findFirstSet((<span style="color:#66d9ef">uint64_t</span>)Hi52);
</span></span><span style="display:flex;"><span>   Hi52 <span style="color:#f92672">=</span> SignExtend64(Hi52 <span style="color:#f92672">&gt;&gt;</span> (ShiftAmount <span style="color:#f92672">-</span> <span style="color:#ae81ff">12</span>), <span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span> ShiftAmount);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// If the remaining bits don&#39;t fit in 12 bits, we might be able to reduce the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// shift amount in order to use LUI which will zero the lower 12 bits.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (ShiftAmount <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">12</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isInt<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">12</span><span style="color:#f92672">&gt;</span>(Hi52) <span style="color:#f92672">&amp;&amp;</span> isInt<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">32</span><span style="color:#f92672">&gt;</span>((<span style="color:#66d9ef">uint64_t</span>)Hi52 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>)) {
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// Reduce the shift amount and add zeros to the LSBs so it will match LUI.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ShiftAmount <span style="color:#f92672">-=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>     Hi52 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)Hi52 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Recursive call
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   generateInstSeqImpl(Hi52, ActiveFeatures, Res);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Generation of the instruction
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   Res.push_back(RISCVMatInt<span style="color:#f92672">::</span>Inst(RISCV<span style="color:#f92672">::</span>SLLI, ShiftAmount));
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (Lo12)
</span></span><span style="display:flex;"><span>     Res.push_back(RISCVMatInt<span style="color:#f92672">::</span>Inst(RISCV<span style="color:#f92672">::</span>ADDI, Lo12));
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>Let&rsquo;s understand this piece of recursive code step by step. Note that the given value is a 64-bits signed integer!</p>
<ol start="0">
<li>
<p>If the value fits in 32 bits, it <strong>splits it in 20 + 12</strong> and performs the usual <code>lui</code>+<code>addi(w)</code> <em>*if needed*</em></p>
<p><em>Note: Since this code is used recursively, this is the last part that will execute.</em></p>
<p>Otherwise:</p>
</li>
<li>
<p><strong>Extract</strong> the <strong>lowest 12 bits</strong> from the constant and sign-extended to 64 bits.</p>
</li>
<li>
<p><strong>Extract</strong> the <strong>highest 52 bits</strong> by first adding <code>0x800</code> then shifting left by 12 bits.</p>
<p><em>Note: the addition will automatically verify the bit sign, if it is 1 it will be propagated as we want otherwise it will not do anything.</em></p>
</li>
<li>
<p><strong>Find</strong> the optimal <strong>shift amount</strong> by looking into the highest 52 bits for the <strong>first set bit</strong>, if it is greater than 12, shift the <code>Hi52</code> as well so it takes it in consideration.</p>
</li>
<li>
<p>If the remaining bits do not fit in 12 bits, the shift amount can be reduced following certain conditions.</p>
</li>
<li>
<p>Finally, call <strong>recursively</strong> the function and push back the FF0</p>
</li>
</ol>
<p><em>Note: The constant is processed from LSB to MSB (right to left) but instruction emission is performed from MSB to LSB (right to left).</em></p>
<h2 id="notes">Notes:</h2>
<ul>
<li>LLVM Comments:</li>
</ul>
<p><em>In the worst case, for a full 64-bit constant, a sequence of 8 instructions (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note that the first two instructions (LUI+ADDIW) can contribute up to 32 bits while the following ADDI instructions contribute up to 12 bits each.</em></p>
<p><em>On the first glance, implementing this seems to be possible by simply emitting the most significant 32 bits (LUI+ADDIW) followed by as many left shift (SLLI) and immediate additions (ADDI) as needed. However, due to the fact that ADDI performs a sign extended addition, doing it like that would only be possible when at most 11 bits of the ADDI instructions are used. Using all 12 bits of the ADDI instructions, like done by GAS, actually requires that the constant is processed starting with the least significant bit.</em></p>
<p><em>In the following, constants are processed from LSB to MSB but instruction emission is performed from MSB to LSB by recursively calling <code>generateInstSeq</code>. In each recursion, first the lowest 12 bits are removed from the constant and the optimal shift amount, which can be greater than 12 bits if the constant is sparse, is determined. Then, the shifted remaining constant is processed recursively and gets emitted as soon as it fits into 32 bits. The emission of the shifts and additions is subsequently performed when the recursion returns.</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-smalltalk" data-lang="smalltalk"><span style="display:flex;"><span><span style="color:#a6e22e">recursiveLoadImmediate:</span> anImmediate <span style="color:#a6e22e">inRegister:</span> aRegister <span style="color:#a6e22e">andEmitInstructionsIn:</span> aCollection
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">&#34;LLVM uses a clever recursive way to determine the best combination of instructions that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 are needed by the pseudo instruction li.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	https://github.com/llvm/llvm-project/blob/4c3d916c4bd2a392101c74dd270bd1e6a4fec15b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">|</span> hi20 lo12 hi52 shiftAmount signedImmediate <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>	self <span style="color:#a6e22e">flag:</span> <span style="color:#e6db74">#TODO</span>.
</span></span><span style="display:flex;"><span>	signedImmediate <span style="color:#f92672">:=</span> anImmediate <span style="color:#a6e22e">signedIntFromLong64</span>.
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">&#34;Special case if the value is 16rFFFFFFFFFFFFFFFF (max)&#34;</span>
</span></span><span style="display:flex;"><span>	(signedImmediate <span style="color:#a6e22e">=</span> <span style="color:#ae81ff">-1</span>)
</span></span><span style="display:flex;"><span>		ifTrue: [ aCollection <span style="color:#a6e22e">add:</span> (self <span style="color:#a6e22e">addImmediate:</span> <span style="color:#ae81ff">-1</span> <span style="color:#a6e22e">toRegister:</span> <span style="color:#a6e22e">X0</span> <span style="color:#a6e22e">inRegister:</span> aRegister).
</span></span><span style="display:flex;"><span>					 <span style="color:#75715e">&#34;End the recursion!&#34;</span>
</span></span><span style="display:flex;"><span>					 <span style="color:#f92672">^</span> <span style="color:#ae81ff">0</span> ].
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">&#34;Check if the immediate can be contained in 32 bits&#34;</span>		
</span></span><span style="display:flex;"><span>	(self <span style="color:#a6e22e">value:</span> signedImmediate <span style="color:#a6e22e">isContainedIn:</span> <span style="color:#ae81ff">31</span>)
</span></span><span style="display:flex;"><span>		ifTrue: [
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">&#34;Depending on the value of the immediate, the following instructions are emitted:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				imm == 0                          : ADDI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				imm[0,12) != 0 &amp;&amp; imm[12,32) == 0 : ADDI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			   imm[0,12) == 0 &amp;&amp; imm[12,32) != 0 : LUI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				imm[0,32) != 0                    : LUI+ADDIW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			&#34;</span>
</span></span><span style="display:flex;"><span>			hi20 <span style="color:#f92672">:=</span> (((self <span style="color:#a6e22e">computeSignedValue64Bits:</span> signedImmediate) <span style="color:#a6e22e">+</span> <span style="color:#ae81ff">16r800</span>) <span style="color:#a6e22e">&gt;&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#a6e22e">bitAnd:</span> <span style="color:#ae81ff">16</span><span style="color:#a6e22e">rFFFFF</span>.
</span></span><span style="display:flex;"><span>			lo12 <span style="color:#f92672">:=</span> self <span style="color:#a6e22e">computeSignedValue64Bits:</span> (signedImmediate <span style="color:#a6e22e">bitAnd:</span> <span style="color:#ae81ff">16</span><span style="color:#a6e22e">rFFF</span>).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">&#34;lui instruction&#34;</span>
</span></span><span style="display:flex;"><span>			hi20 <span style="color:#a6e22e">~=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>				ifTrue: [ aCollection <span style="color:#a6e22e">add:</span> (self <span style="color:#a6e22e">loadUpperImmediate:</span> hi20 <span style="color:#a6e22e">inRegister:</span> aRegister) ].
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			((lo12 <span style="color:#a6e22e">~=</span> <span style="color:#ae81ff">0</span>) <span style="color:#a6e22e">or:</span> [hi20 <span style="color:#a6e22e">=</span> <span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>				ifTrue: [ hi20 <span style="color:#a6e22e">~=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>						ifTrue: [ aCollection <span style="color:#a6e22e">add:</span> (self <span style="color:#a6e22e">addWordImmediate:</span> lo12 <span style="color:#a6e22e">toRegister:</span> aRegister <span style="color:#a6e22e">inRegister:</span> aRegister)]
</span></span><span style="display:flex;"><span>						ifFalse: [ aCollection <span style="color:#a6e22e">add:</span> (self <span style="color:#a6e22e">addImmediate:</span> lo12 <span style="color:#a6e22e">toRegister:</span> <span style="color:#a6e22e">X0</span> <span style="color:#a6e22e">inRegister:</span> aRegister) ]
</span></span><span style="display:flex;"><span>					].
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">&#34;Return to end the recursion&#34;</span>			
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">^</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		].
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">&#34;In the case the value does not fit in 32 bits&#34;</span>
</span></span><span style="display:flex;"><span>		lo12 <span style="color:#f92672">:=</span> self <span style="color:#a6e22e">computeSignedValue64Bits:</span> (signedImmediate <span style="color:#a6e22e">bitAnd:</span> <span style="color:#ae81ff">16</span><span style="color:#a6e22e">rFFF</span>).
</span></span><span style="display:flex;"><span>		hi52 <span style="color:#f92672">:=</span> (((self <span style="color:#a6e22e">computeSignedValue64Bits:</span> signedImmediate) <span style="color:#a6e22e">+</span> <span style="color:#ae81ff">16r800</span>) <span style="color:#a6e22e">bitAnd:</span> <span style="color:#ae81ff">16</span><span style="color:#a6e22e">rFFFFFFFFFFFFFFFF</span>) <span style="color:#a6e22e">&gt;&gt;</span> <span style="color:#ae81ff">12</span>.
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">&#34;Process the optimal shift amount&#34;</span>
</span></span><span style="display:flex;"><span>		shiftAmount <span style="color:#f92672">:=</span> <span style="color:#ae81ff">12</span> <span style="color:#a6e22e">+</span> (self <span style="color:#a6e22e">trailingZerosOf:</span> hi52).
</span></span><span style="display:flex;"><span>		hi52 <span style="color:#f92672">:=</span> self <span style="color:#a6e22e">computeSignedValueOf:</span> hi52 <span style="color:#a6e22e">&gt;&gt;</span> (shiftAmount <span style="color:#a6e22e">-</span> <span style="color:#ae81ff">12</span>) <span style="color:#a6e22e">ofSize:</span> (<span style="color:#ae81ff">64</span> <span style="color:#a6e22e">-</span> shiftAmount).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">&#34;Check if the shift amount can be reduced to fit in a 32 bit variable&#34;</span>
</span></span><span style="display:flex;"><span>		((shiftAmount <span style="color:#a6e22e">&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#a6e22e">and:</span> [((hi52 <span style="color:#a6e22e">bitAnd:</span> <span style="color:#ae81ff">16</span><span style="color:#a6e22e">rFFF</span>) <span style="color:#a6e22e">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#a6e22e">and:</span> [self <span style="color:#a6e22e">value:</span> (hi52 <span style="color:#a6e22e">&lt;&lt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#a6e22e">isContainedIn:</span> <span style="color:#ae81ff">32</span>]])
</span></span><span style="display:flex;"><span>			ifTrue: [
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">&#34;Reduce the shift amount&#34;</span>  
</span></span><span style="display:flex;"><span>				shiftAmount <span style="color:#f92672">:=</span> shiftAmount <span style="color:#a6e22e">-</span> <span style="color:#ae81ff">12</span>.
</span></span><span style="display:flex;"><span>				hi52 <span style="color:#f92672">:=</span> self <span style="color:#a6e22e">computeSignedValueOf:</span> hi52 <span style="color:#a6e22e">&lt;&lt;</span> <span style="color:#ae81ff">12</span> <span style="color:#a6e22e">ofSize:</span> <span style="color:#ae81ff">64</span>.
</span></span><span style="display:flex;"><span>			].
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">&#34; Recursive call&#34;</span>
</span></span><span style="display:flex;"><span>		self <span style="color:#a6e22e">recursiveLoadImmediate:</span> hi52 <span style="color:#a6e22e">inRegister:</span> aRegister <span style="color:#a6e22e">andEmitInstructionsIn:</span> aCollection.
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">&#34;Add shift and add&#34;</span>		
</span></span><span style="display:flex;"><span>		aCollection <span style="color:#a6e22e">add:</span> (self <span style="color:#a6e22e">shiftLeftValueInRegister:</span> aRegister <span style="color:#a6e22e">byShiftAmount:</span> shiftAmount <span style="color:#a6e22e">intoRegister:</span> aRegister).
</span></span><span style="display:flex;"><span>		lo12 <span style="color:#a6e22e">~=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>			ifTrue: [ aCollection <span style="color:#a6e22e">add:</span> (self <span style="color:#a6e22e">addImmediate:</span> lo12 <span style="color:#a6e22e">toRegister:</span> aRegister <span style="color:#a6e22e">inRegister:</span> aRegister) ].
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">^</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div>
        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-tags">
              <a href="/tags/riscv/">
                riscv
              </a>
            </div>
            
          </div>
        </div>
        
          <div class="row">
            <div class="col-xs-12">
              
            </div>
          </div>

          



          
          
          <div style="height: 50px;"></div>
          
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  

<script>
  
  
    
    
  
</script>

  

</body>

</html>